// REFERENCE: System.Drawing.dll
// REFERENCE: ConvertColor.dll
// PLATFORM: x86

#define TRACE

using ConvertColor;

using System.Collections.Generic;
using System.Console;
using System.Drawing;
using System.Diagnostics;
using System.Globalization;
using System.Math;
using System.IO;
using System.Threading;

def lRange     = (   0.0, 100.0);
def aRange     = ( -86.0,  99.0);
def bRange     = (-108.0,  96.0);
def cellSize   = 1.0f;
def σ          = 1.0f;
def maxEntries = 10_000_000;

def Load(path)
{
	using (txt = File.OpenText(path))
	{
		WriteLine("Reading data...");

		// skip header
		def header = txt.ReadLine();
		Trace.Assert(header == "index\trank\thex\tvotes\tcomments\thearts", "header");

		def entries = List();
		for (mutable line = txt.ReadLine(); line != null && entries.Count < maxEntries; line = txt.ReadLine())
		{
			def parts = line.Split(array['\t']);
			def color = Color.FromArgb(int.Parse(parts[2], NumberStyles.HexNumber));
			def votes = int.Parse(parts[3]);

			def (l, a, b) = color |> ColorToRgb |> RgbToXyz |> XyzToLab;
			def tx = (l - lRange[0]) / cellSize;
			def ty = (a - aRange[0]) / cellSize;
			def tz = (b - bRange[0]) / cellSize;
			entries.Add(tx, ty, tz, votes);
		}
		WriteLine("Loaded {0} entries", entries.Count);
		entries;
	}
}

/*
def GenerateData()
{
	def MakeData(color)
	{
		def (l, a, b) = Color.FromArgb(color) |> ColorToRgb |> RgbToXyz |> XyzToLab;
		def tx = (l - lRange[0]) / cellSize;
		def ty = (a - aRange[0]) / cellSize;
		def tz = (b - bRange[0]) / cellSize;
		(tx, ty, tz, 1);
	}
	[ 0xFDD75A, 0xFBA84C, 0xEA736B, 0xAB6B5B, 0xA1A362 ].Map(MakeData)
}
*/

def CreateThreads(dataCount, threadCount, f)
{
	def threads = array(threadCount);
	mutable prev = 0;
	for (mutable i = 0; i != threadCount; ++i)
	{
		def fi    = i;
		def begin = prev;
		def end   = dataCount * (i + 1) / threadCount;
		threads[i] = Thread(() => f(fi, begin, end));
		prev = end;
	}
	threads;
}

def Voxelize(data)
{
	def nx = (Floor((lRange[1] - lRange[0]) / cellSize) :> int) + 1;
	def ny = (Floor((aRange[1] - aRange[0]) / cellSize) :> int) + 1;
	def nz = (Floor((bRange[1] - bRange[0]) / cellSize) :> int) + 1;

	WriteLine("Voxelizing {0}x{1}x{2} grid", nx, ny, nz);

	def volume : array[double] = array(nx * ny * nz);

	def VoxelizeRange(threadID, start, finish)
	{
		def scale = -0.5 / σ / σ;

		def vol : array[double] = array(volume.Length);

		def watch = Stopwatch.StartNew();

		for (mutable i = start, i != finish; ++i)
		{
			when (i % 10 == 0 && watch.ElapsedMilliseconds >= 60_000)
			{
				def done    = i - start;
				def outOf   = finish - start;
				def percent = done * 100 / outOf;
				WriteLine("thread {0} at {1} / {2} ({3}%)", threadID, done, outOf, percent);
				watch.Restart();
			}

			def (tx, ty, tz, n) : double * double * double * int = data[i];
			def n = n :> double;
			for (mutable z = 0; z != nz; ++z)
			{
				def δzSq = tz - z;
				def δzSq = δzSq * δzSq;
				for (mutable y = 0; y != ny; ++y)
				{
					def δySq = ty - y;
					def δySq = δySq * δySq;
					for (mutable x = 0; x != nx; ++x)
					{
						def δxSq = tx - x;
						def δxSq = δxSq * δxSq;
						vol[x + nx * y  + nx * ny * z] += n * Exp(scale * (δxSq + δySq + δzSq));
					}
				}
			}
		}
		lock (volume)
		{
			for (mutable i = 0; i != volume.Length; ++i)
				volume[i] += vol[i];
		}
	}

	def threads = CreateThreads(data.Count, 3, VoxelizeRange);
	foreach (t in threads)
		t.Start();
	foreach (t in threads)
		t.Join();
	(nx, ny, nz, volume);
}

def Save((nx, ny, nz, volume), path)
{
	WriteLine("Saving...");
	using (w = BinaryWriter(File.Create(path)))
	{
		w.Write(nx);
		w.Write(ny);
		w.Write(nz);
		for (mutable i = 0; i != volume.Length; ++i)
			w.Write(volume[i]);
	}
}

def watch = Stopwatch.StartNew();
Save(Voxelize(Load(@"..\get colors\data.txt")), "volume.dat");
//Save(Voxelize(GenerateData()), "volume.dat");
WriteLine("{0} seconds", watch.Elapsed.TotalSeconds);
