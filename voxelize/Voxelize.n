// REFERENCE: System.Drawing.dll
// REFERENCE: ConvertColor.dll
// PLATFORM: x64

#define TRACE

using ConvertColor;

using Nemerle.Collections;
using System.Collections.Generic;
using System.Console;
using System.Drawing;
using System.Diagnostics;
using System.Globalization;
using System.Math;
using System.IO;
using System.Threading;

def lRange     = (   0.0, 100.0);
def aRange     = ( -87.0,  99.0);
def bRange     = (-108.0,  96.0);
def cellSize   = 1.0f;
def σ          = 3.0f;

def nx = (Floor((lRange[1] - lRange[0]) / cellSize) :> int) + 1;
def ny = (Floor((aRange[1] - aRange[0]) / cellSize) :> int) + 1;
def nz = (Floor((bRange[1] - bRange[0]) / cellSize) :> int) + 1;

def Load(path)
{
	using (reader = BinaryReader(File.OpenRead(path)))
	{
		WriteLine("Reading data...");
		def watch = Stopwatch.StartNew();

		def count = reader.ReadInt32();

		def entries = List();
		entries.Capacity = count;
		repeat (count)
		{
			def r = reader.ReadDouble() / 255.0;
			def g = reader.ReadDouble() / 255.0;
			def b = reader.ReadDouble() / 255.0;

			def (l, a, b) = (r, g, b) |> RgbToXyz |> XyzToLab;
			def tx = (l - lRange[0]) / cellSize;
			def ty = (a - aRange[0]) / cellSize;
			def tz = (b - bRange[0]) / cellSize;
			Trace.Assert(tx >= 0 && tx < nx);
			Trace.Assert(ty >= 0 && ty < ny);
			Trace.Assert(tz >= 0 && tz < nz);

			entries.Add(tx, ty, tz);
		}
		WriteLine("Loaded {0:N0} entries {1:N0} seconds", entries.Count, watch.Elapsed.TotalSeconds);
		entries.ToArray();
	}
}

def CreateThreads(dataCount, threadCount, f)
{
	def threads = array(threadCount);
	mutable prev = 0;
	for (mutable i = 0; i != threadCount; ++i)
	{
		def fi    = i;
		def begin = prev;
		def end   = dataCount * (i + 1) / threadCount;
		threads[i] = Thread(() => f(fi, begin, end));
		prev = end;
	}
	threads;
}

def Voxelize(data)
{
	WriteLine("Voxelizing {0}x{1}x{2} grid", nx, ny, nz);

	def volume : array[double] = array(nx * ny * nz);

	def VoxelizeRange(threadID, start, finish)
	{
		def scale = -0.5 * cellSize * cellSize / σ / σ;

		def n = Ceiling(4.0 * σ / cellSize) :> int;

		def vol : array[double] = array(volume.Length);

		def watch = Stopwatch.StartNew();

		for (mutable i = start, i != finish; ++i)
		{
			when (i % 10 == 0 && watch.ElapsedMilliseconds >= 60_000)
			{
				def done    = i - start;
				def outOf   = finish - start;
				def percent = done * 100.0 / outOf;
				WriteLine("thread {0} at {1} / {2} ({3:F1}%)", threadID, done, outOf, percent);
				watch.Restart();
			}

			def (xs, ys, zs) = data[i];

			def cx = (xs : double) :> int;
			def cy = (ys : double) :> int;
			def cz = (zs : double) :> int;

			def (minX, maxX) = (Max(0, cx - n), Min(cx + n, nx - 1));
			def (minY, maxY) = (Max(0, cy - n), Min(cy + n, ny - 1));
			def (minZ, maxZ) = (Max(0, cz - n), Min(cz + n, nz - 1));

			for (mutable z = minZ; z <= maxZ; ++z)
			for (mutable y = minY; y <= maxY; ++y)
			for (mutable x = minX; x <= maxX; ++x)
			{
				def δx = xs - x - 0.5f;
				def δy = ys - y - 0.5f;
				def δz = zs - z - 0.5f;

				vol[(z * ny + y) * nx + x] += Exp(scale * (δx * δx + δy * δy + δz * δz));
			}
		}
		lock (volume)
		{
			for (mutable i; i != volume.Length; ++i)
				volume[i] += vol[i];
		}
	}

	def threads = CreateThreads(data.Length, 3, VoxelizeRange);
	foreach (t in threads)
		t.Start();
	foreach (t in threads)
		t.Join();

	for (mutable i; i != volume.Length; ++i)
		volume[i] *= Pow(σ * Sqrt(2.0 * PI), -3.0);

	WriteLine
		( "mean: {0:F2}; max: {1:F2}; sum: {2:N0}"
		, volume.Fold(0.0, _ + _) / volume.Length
		, volume.Fold(0.0, Max)
		, volume.Fold(0.0, _ + _) * Pow(cellSize, 3.0)
		);

	(nx, ny, nz, volume);
}

def Save((nx, ny, nz, volume), path)
{
	WriteLine("Saving...");
	using (w = BinaryWriter(File.Create(path)))
	{
		w.Write(nx);
		w.Write(ny);
		w.Write(nz);
		for (mutable i = 0; i != volume.Length; ++i)
			w.Write(volume[i]);
	}
}

def watch = Stopwatch.StartNew();
Save(Voxelize(Load(@"..\get samples\samples.dat")), "volume s3.dat");
WriteLine("{0} seconds", watch.Elapsed.TotalSeconds);
